// Copyright 2025 Bytedance Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// code generated by go run gen.go; DO NOT EDIT.

package stream

import (
	"context"

	"github.com/bytedance/gg/internal/constraints"
	"github.com/bytedance/gg/internal/iter"
)

// Orderable is a constraints.Ordered variant of Comparable.
type Orderable[T constraints.Ordered] struct {
	Comparable[T]
}

// FromIter wraps an [github.com/bytedance/gg/internal/iter.Iter] to [Stream].
func FromOrderableIter[T constraints.Ordered](i iter.Iter[T]) Orderable[T] {
	return Orderable[T]{FromComparableIter(i)}
}

// See function [github.com/bytedance/gg/internal/iter.FromSlice].
func FromOrderableSlice[T constraints.Ordered](s []T) Orderable[T] {
	return Orderable[T]{FromComparableSlice(s)}
}

// See function [github.com/bytedance/gg/internal/iter.StealSlice].
func StealOrderableSlice[T constraints.Ordered](s []T) Orderable[T] {
	return Orderable[T]{StealComparableSlice(s)}
}

// See function [github.com/bytedance/gg/internal/iter.FromMapValues].
func FromOrderableMapValues[I comparable, T constraints.Ordered](m map[I]T) Orderable[T] {
	return Orderable[T]{FromComparableMapValues(m)}
}

// See function [github.com/bytedance/gg/internal/iter.FromChan].
func FromOrderableChan[T constraints.Ordered](ctx context.Context, ch <-chan T) Orderable[T] {
	return Orderable[T]{FromComparableChan(ctx, ch)}
}

// See function [github.com/bytedance/gg/internal/iter.Repeat].
func RepeatOrderable[T constraints.Ordered](v T) Orderable[T] {
	return Orderable[T]{RepeatComparable(v)}
}

// See function [github.com/bytedance/gg/internal/iter.MapInplace].
func (s Orderable[T]) Map(f func(T) T) Orderable[T] {
	return Orderable[T]{s.Comparable.Map(f)}
}

// See function [github.com/bytedance/gg/internal/iter.FlatMap].
func (s Orderable[T]) FlatMap(f func(T) []T) Orderable[T] {
	return Orderable[T]{s.Comparable.FlatMap(f)}
}

// See function [github.com/bytedance/gg/internal/iter.Filter].
func (s Orderable[T]) Filter(f func(T) bool) Orderable[T] {
	return Orderable[T]{s.Comparable.Filter(f)}
}

// See function [github.com/bytedance/gg/internal/iter.Reverse].
func (s Orderable[T]) Reverse() Orderable[T] {
	return Orderable[T]{s.Comparable.Reverse()}
}

// See function [github.com/bytedance/gg/internal/iter.Take].
func (s Orderable[T]) Take(n int) Orderable[T] {
	return Orderable[T]{s.Comparable.Take(n)}
}

// See function [github.com/bytedance/gg/internal/iter.Drop].
func (s Orderable[T]) Drop(n int) Orderable[T] {
	return Orderable[T]{s.Comparable.Drop(n)}
}

// See function [github.com/bytedance/gg/internal/iter.Concat].
func (s Orderable[T]) Concat(ss ...Orderable[T]) Orderable[T] {
	conv := func(c Orderable[T]) Comparable[T] {
		return c.Comparable
	}
	tmp := iter.ToSlice(iter.Map(conv, iter.FromSlice(ss)))
	return Orderable[T]{s.Comparable.Concat(tmp...)}
}

// See function [github.com/bytedance/gg/internal/iter.Zip].
func (s Orderable[T]) Zip(f func(T, T) T, another Orderable[T]) Orderable[T] {
	return Orderable[T]{s.Comparable.Zip(f, another.Comparable)}
}

// See function [github.com/bytedance/gg/internal/iter.Intersperse].
func (s Orderable[T]) Intersperse(sep T) Orderable[T] {
	return Orderable[T]{s.Comparable.Intersperse(sep)}
}

// See function [github.com/bytedance/gg/internal/iter.Append].
func (s Orderable[T]) Append(tail T) Orderable[T] {
	return Orderable[T]{s.Comparable.Append(tail)}
}

// See function [github.com/bytedance/gg/internal/iter.Prepend].
func (s Orderable[T]) Prepend(head T) Orderable[T] {
	return Orderable[T]{s.Comparable.Prepend(head)}
}

// See function [github.com/bytedance/gg/internal/iter.TakeWhile].
func (s Orderable[T]) TakeWhile(f func(T) bool) Orderable[T] {
	return Orderable[T]{s.Comparable.TakeWhile(f)}
}

// See function [github.com/bytedance/gg/internal/iter.DropWhile].
func (s Orderable[T]) DropWhile(f func(T) bool) Orderable[T] {
	return Orderable[T]{s.Comparable.DropWhile(f)}
}

// See function [github.com/bytedance/gg/internal/iter.SortBy].
func (s Orderable[T]) SortBy(less func(T, T) bool) Orderable[T] {
	return Orderable[T]{s.Comparable.SortBy(less)}
}

// See function [github.com/bytedance/gg/internal/iter.UniqBy].
func (s Orderable[T]) UniqBy(f func(T) any) Orderable[T] {
	return Orderable[T]{s.Comparable.UniqBy(f)}
}

// See function [github.com/bytedance/gg/internal/iter.Shuffle].
func (s Orderable[T]) Shuffle() Orderable[T] {
	return Orderable[T]{s.Comparable.Shuffle()}
}

// See function [github.com/bytedance/gg/internal/iter.FromMapKeys].
func FromOrderableMapKeys[T constraints.Ordered, I any](m map[T]I) Orderable[T] {
	return Orderable[T]{FromMapKeys(m)}
}

// See function [github.com/bytedance/gg/internal/iter.Uniq].
func (s Orderable[T]) Uniq() Orderable[T] {
	return Orderable[T]{s.Comparable.Uniq()}
}

// See function [github.com/bytedance/gg/internal/iter.Remove].
func (s Orderable[T]) Remove(v T) Orderable[T] {
	return Orderable[T]{s.Comparable.Remove(v)}
}

// See function [github.com/bytedance/gg/internal/iter.RemoveN].
func (s Orderable[T]) RemoveN(v T, n int) Orderable[T] {
	return Orderable[T]{s.Comparable.RemoveN(v, n)}
}
